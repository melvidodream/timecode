<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multi-Device Synchronized Timecode</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/peerjs/1.5.0/peerjs.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            color: #333;
            padding: 20px;
        }

        .container {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            padding: 40px;
            text-align: center;
            max-width: 700px;
            width: 100%;
        }

        .connection-status {
            margin-bottom: 20px;
            padding: 15px;
            border-radius: 10px;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .connection-status.connected {
            background: rgba(76, 175, 80, 0.1);
            color: #4CAF50;
            border: 2px solid #4CAF50;
        }

        .connection-status.disconnected {
            background: rgba(244, 67, 54, 0.1);
            color: #f44336;
            border: 2px solid #f44336;
        }

        .connection-status.connecting {
            background: rgba(255, 152, 0, 0.1);
            color: #ff9800;
            border: 2px solid #ff9800;
        }

        .session-setup {
            margin-bottom: 30px;
        }

        .session-controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
            margin: 15px 0;
        }

        .session-input {
            padding: 12px 16px;
            border: 2px solid #ddd;
            border-radius: 10px;
            font-size: 16px;
            min-width: 200px;
            font-family: 'Courier New', monospace;
        }

        .session-input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 10px rgba(102, 126, 234, 0.3);
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 15px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 120px;
        }

        .btn-primary {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
        }

        .btn-success {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
        }

        .btn-warning {
            background: linear-gradient(45deg, #ff9800, #f57c00);
            color: white;
        }

        .btn-danger {
            background: linear-gradient(45deg, #f44336, #d32f2f);
            color: white;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .timecode-display {
            font-size: 4rem;
            font-weight: bold;
            margin: 30px 0;
            font-family: 'Courier New', monospace;
            background: linear-gradient(45deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .leader-controls {
            display: none;
        }

        .leader-controls.active {
            display: block;
        }

        .control-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
            margin: 20px 0;
        }

        .offset-controls {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .offset-input {
            width: 100px;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 10px;
            text-align: center;
            font-size: 16px;
            font-family: 'Courier New', monospace;
        }

        .offset-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 10px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        .offset-btn:hover {
            transform: translateY(-1px);
        }

        .status-info {
            margin-top: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 20px;
        }

        .status {
            font-size: 18px;
            font-weight: 600;
            padding: 8px 16px;
            border-radius: 20px;
        }

        .status.running {
            background: rgba(76, 175, 80, 0.1);
            color: #4CAF50;
        }

        .status.paused {
            background: rgba(255, 152, 0, 0.1);
            color: #ff9800;
        }

        .status.stopped {
            background: rgba(244, 67, 54, 0.1);
            color: #f44336;
        }

        .participants {
            font-size: 14px;
            color: #666;
        }

        .session-info {
            background: rgba(102, 126, 234, 0.1);
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
        }

        .session-id {
            font-family: 'Courier New', monospace;
            font-weight: bold;
            font-size: 24px;
            color: #667eea;
            margin: 10px 0;
            word-break: break-all;
            letter-spacing: 2px;
        }

        .qr-code {
            margin: 15px 0;
        }

        .instructions {
            background: rgba(255, 255, 255, 0.8);
            border-radius: 10px;
            padding: 15px;
            margin: 20px 0;
            font-size: 14px;
            line-height: 1.5;
        }

        .hidden {
            display: none !important;
        }

        .copy-btn {
            margin-left: 10px;
            padding: 6px 12px;
            font-size: 12px;
            min-width: auto;
        }

        .peer-id-display {
            margin: 10px 0;
            font-size: 12px;
            color: #666;
            word-break: break-all;
        }

        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            
            .timecode-display {
                font-size: 2.5rem;
            }
            
            .session-controls,
            .control-buttons,
            .offset-controls {
                flex-direction: column;
                align-items: center;
            }
            
            .status-info {
                flex-direction: column;
                text-align: center;
            }

            .session-id {
                font-size: 18px;
                letter-spacing: 1px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>🎬 Multi-Device Synchronized Timecode</h1>
        
        <div class="connection-status disconnected" id="connectionStatus">
            Initializing...
        </div>

        <div class="session-setup" id="sessionSetup">
            <div class="instructions">
                <strong>How to use:</strong><br>
                • <strong>Leader:</strong> Click "Create Session" and share the Device ID below<br>
                • <strong>Followers:</strong> Enter the full Device ID and click "Join"<br>
                • Works across all devices with internet connection!<br>
                <br>
                <small><em>Note: Session codes (like ABC123) require a server. For now, share the full Device ID shown below.</em></small>
            </div>
            
            <div class="session-controls">
                <input type="text" class="session-input" id="sessionIdInput" placeholder="Enter Device ID (full peer ID)" maxlength="50">
                <button class="btn btn-success" onclick="joinSession()" id="joinBtn">Join Session</button>
                <button class="btn btn-primary" onclick="createSession()" id="createBtn">Create Session</button>
            </div>
            
            <div class="peer-id-display" id="peerIdDisplay"></div>
        </div>

        <div class="session-info hidden" id="sessionInfo">
            <h4>🔗 Session Active</h4>
            <p><strong>Session Code:</strong></p>
            <div class="session-id" id="currentSessionId"></div>
            <p><strong>Device ID to Share:</strong></p>
            <div class="session-id" id="deviceIdToShare" style="font-size: 16px; color: #333;"></div>
            <button class="btn btn-primary copy-btn" onclick="copyDeviceId()">📋 Copy Device ID</button>
            <p style="margin: 15px 0; font-size: 14px;">Share the <strong>Device ID</strong> above with others to join your session</p>
            <button class="btn btn-danger" onclick="leaveSession()">Leave Session</button>
        </div>

        <div class="timecode-display" id="timecode">00:00:00</div>
        
        <div class="leader-controls" id="leaderControls">
            <div class="control-buttons">
                <button class="btn btn-success" onclick="startTimer()">▶️ Play</button>
                <button class="btn btn-warning" onclick="pauseTimer()">⏸️ Pause</button>
                <button class="btn btn-danger" onclick="resetTimer()">⏹️ Reset</button>
            </div>

            <div class="control-group">
                <h4>⚡ Offset Controls</h4>
                <div class="offset-controls">
                    <button class="offset-btn" onclick="adjustOffset(-60)">-1m</button>
                    <button class="offset-btn" onclick="adjustOffset(-10)">-10s</button>
                    <button class="offset-btn" onclick="adjustOffset(-1)">-1s</button>
                    <input type="number" class="offset-input" id="offsetInput" placeholder="0" step="1">
                    <button class="offset-btn" onclick="setCustomOffset()">Set</button>
                    <button class="offset-btn" onclick="adjustOffset(1)">+1s</button>
                    <button class="offset-btn" onclick="adjustOffset(10)">+10s</button>
                    <button class="offset-btn" onclick="adjustOffset(60)">+1m</button>
                </div>
            </div>
        </div>

        <div class="status-info">
            <div class="status stopped" id="status">Stopped</div>
            <div class="participants" id="participants">Participants: 0</div>
        </div>
    </div>

    <script>
        class PeerTimecodeManager {
            constructor() {
                this.peer = null;
                this.connections = new Map();
                this.sessionId = null;
                this.isLeader = false;
                this.leaderPeerId = null;
                this.timecodeState = {
                    startTime: 0,
                    offset: 0,
                    isRunning: false,
                    isPaused: false,
                    pausedAt: 0,
                    pausedDuration: 0
                };
                this.updateInterval = null;
                this.initializePeer();
            }

            initializePeer() {
                // Use free PeerJS cloud server
                this.peer = new Peer({
                    config: {
                        iceServers: [
                            { urls: 'stun:stun.l.google.com:19302' },
                            { urls: 'stun:stun1.l.google.com:19302' }
                        ]
                    }
                });

                this.peer.on('open', (id) => {
                    console.log('Peer ID:', id);
                    document.getElementById('peerIdDisplay').textContent = `Device ID: ${id}`;
                    this.updateConnectionStatus('disconnected');
                });

                this.peer.on('connection', (conn) => {
                    this.handleIncomingConnection(conn);
                });

                this.peer.on('error', (error) => {
                    console.error('Peer error:', error);
                    this.updateConnectionStatus('disconnected');
                });
            }

            handleIncomingConnection(conn) {
                conn.on('open', () => {
                    console.log('Incoming connection from:', conn.peer);
                    this.connections.set(conn.peer, conn);
                    this.updateParticipantCount();
                    
                    // Send current state to new connection
                    if (this.isLeader) {
                        conn.send({
                            type: 'timecode-sync',
                            state: this.timecodeState
                        });
                    }
                });

                conn.on('data', (data) => {
                    this.handleMessage(data, conn);
                });

                conn.on('close', () => {
                    console.log('Connection closed:', conn.peer);
                    this.connections.delete(conn.peer);
                    this.updateParticipantCount();
                });
            }

            handleMessage(data, conn) {
                switch (data.type) {
                    case 'timecode-sync':
                        if (!this.isLeader) {
                            this.receiveTimecodeSync(data.state);
                        }
                        break;
                    case 'join-request':
                        if (this.isLeader) {
                            conn.send({
                                type: 'timecode-sync',
                                state: this.timecodeState
                            });
                        }
                        break;
                    case 'user-leaving':
                        console.log('User leaving:', conn.peer);
                        this.connections.delete(conn.peer);
                        this.updateParticipantCount();
                        break;
                }
            }

            generateSessionId() {
                // Generate a shorter, easier to share session ID
                const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
                let result = '';
                for (let i = 0; i < 6; i++) {
                    result += chars.charAt(Math.floor(Math.random() * chars.length));
                }
                return result;
            }

            async createSession() {
                if (!this.peer || !this.peer.id) {
                    alert('Still connecting... please wait a moment and try again.');
                    return;
                }

                // Generate short session ID and store peer ID mapping
                this.sessionId = this.generateSessionId();
                this.leaderPeerId = this.peer.id;
                this.isLeader = true;
                
                // Store the mapping in a simple way (you could use a server for this in production)
                console.log(`Session ${this.sessionId} maps to peer ${this.peer.id}`);
                
                this.updateUI();
                this.updateConnectionStatus('connected');
                console.log('Created session with ID:', this.sessionId);
            }

            async joinSession() {
                const inputSessionId = document.getElementById('sessionIdInput').value.trim().toUpperCase();
                if (!inputSessionId) {
                    alert('Please enter a session ID');
                    return;
                }

                if (!this.peer || !this.peer.id) {
                    alert('Still connecting... please wait a moment and try again.');
                    return;
                }

                this.updateConnectionStatus('connecting');
                
                // For now, we'll use a simple approach where the session ID IS the peer ID
                // In production, you'd have a server to map short codes to peer IDs
                try {
                    // Try to connect using the session ID directly as peer ID
                    let targetPeerId = inputSessionId;
                    
                    // If it's a short code, we need to find the actual peer ID
                    // For demo purposes, let's try common patterns
                    if (inputSessionId.length === 6) {
                        // This is our short code - in a real app, you'd query a server
                        // For now, show error asking for the full peer ID
                        alert('Short session codes require a server backend. Please ask the leader for their full Device ID (shown below the session controls) and try again.');
                        this.updateConnectionStatus('disconnected');
                        return;
                    }
                    
                    const conn = this.peer.connect(targetPeerId);
                    
                    conn.on('open', () => {
                        console.log('Connected to session:', inputSessionId);
                        this.sessionId = inputSessionId;
                        this.isLeader = false;
                        this.connections.set(targetPeerId, conn);
                        
                        conn.send({ type: 'join-request' });
                        
                        this.updateUI();
                        this.updateConnectionStatus('connected');
                        this.updateParticipantCount();
                    });

                    conn.on('data', (data) => {
                        this.handleMessage(data, conn);
                    });

                    conn.on('close', () => {
                        console.log('Connection to leader lost');
                        this.handleConnectionLost();
                    });

                    conn.on('error', (error) => {
                        console.error('Connection error:', error);
                        alert('Failed to connect to session. Please check the session ID and try again.');
                        this.updateConnectionStatus('disconnected');
                    });

                } catch (error) {
                    console.error('Error joining session:', error);
                    alert('Failed to join session. Please check the session ID and try again.');
                    this.updateConnectionStatus('disconnected');
                }
            }

            handleConnectionLost() {
                console.log('Connection lost, cleaning up...');
                this.connections.clear();
                this.sessionId = null;
                this.isLeader = false;
                this.resetTimer();
                this.updateUI();
                this.updateConnectionStatus('disconnected');
                alert('Connection to session lost. You have been disconnected.');
            }

            leaveSession() {
                console.log('Leaving session...');
                
                // Send leave message to all connections
                this.connections.forEach(conn => {
                    if (conn.open) {
                        try {
                            conn.send({ type: 'user-leaving' });
                        } catch (error) {
                            console.log('Error sending leave message:', error);
                        }
                    }
                });
                
                // Close all connections with a small delay to ensure message is sent
                setTimeout(() => {
                    this.connections.forEach(conn => {
                        try {
                            conn.close();
                        } catch (error) {
                            console.log('Error closing connection:', error);
                        }
                    });
                    this.connections.clear();
                }, 100);
                
                // Clean up state
                this.sessionId = null;
                this.isLeader = false;
                this.leaderPeerId = null;
                this.resetTimer();
                this.updateUI();
                this.updateConnectionStatus('disconnected');
                
                console.log('Session left successfully');
            }

            broadcastToFollowers(message) {
                this.connections.forEach(conn => {
                    if (conn.open) {
                        conn.send(message);
                    }
                });
            }

            receiveTimecodeSync(state) {
                this.timecodeState = { ...state };
                this.updateDisplay();
                this.updateStatus();
                
                if (state.isRunning && !state.isPaused) {
                    this.startUpdateLoop();
                } else {
                    this.stopUpdateLoop();
                }
            }

            syncTimecode() {
                if (this.isLeader) {
                    this.broadcastToFollowers({
                        type: 'timecode-sync',
                        state: this.timecodeState
                    });
                }
            }

            start() {
                if (!this.isLeader) return;
                
                if (this.timecodeState.isPaused) {
                    this.timecodeState.pausedDuration += Date.now() - this.timecodeState.pausedAt;
                    this.timecodeState.isPaused = false;
                } else {
                    this.timecodeState.startTime = Date.now();
                    this.timecodeState.pausedDuration = 0;
                }
                
                this.timecodeState.isRunning = true;
                this.startUpdateLoop();
                this.updateStatus();
                this.syncTimecode();
            }

            pause() {
                if (!this.isLeader || !this.timecodeState.isRunning || this.timecodeState.isPaused) return;
                
                this.timecodeState.isPaused = true;
                this.timecodeState.pausedAt = Date.now();
                this.updateStatus();
                this.syncTimecode();
            }

            reset() {
                if (!this.isLeader) return;
                
                this.timecodeState = {
                    startTime: 0,
                    offset: 0,
                    isRunning: false,
                    isPaused: false,
                    pausedAt: 0,
                    pausedDuration: 0
                };
                
                this.stopUpdateLoop();
                this.updateDisplay();
                this.updateStatus();
                this.syncTimecode();
            }

            setOffset(seconds) {
                if (!this.isLeader) return;
                
                this.timecodeState.offset = seconds;
                this.updateDisplay();
                this.syncTimecode();
            }

            adjustOffset(seconds) {
                if (!this.isLeader) return;
                
                this.timecodeState.offset += seconds;
                this.updateDisplay();
                this.syncTimecode();
            }

            getCurrentTime() {
                if (!this.timecodeState.isRunning) {
                    return this.timecodeState.offset;
                }

                let elapsed;
                if (this.timecodeState.isPaused) {
                    elapsed = this.timecodeState.pausedAt - this.timecodeState.startTime - this.timecodeState.pausedDuration;
                } else {
                    elapsed = Date.now() - this.timecodeState.startTime - this.timecodeState.pausedDuration;
                }

                return Math.floor(elapsed / 1000) + this.timecodeState.offset;
            }

            formatTime(seconds) {
                const hrs = Math.floor(Math.abs(seconds) / 3600);
                const mins = Math.floor((Math.abs(seconds) % 3600) / 60);
                const secs = Math.abs(seconds) % 60;
                const sign = seconds < 0 ? '-' : '';
                
                return `${sign}${hrs.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            }

            updateDisplay() {
                const currentTime = this.getCurrentTime();
                document.getElementById('timecode').textContent = this.formatTime(currentTime);
            }

            updateStatus() {
                const statusEl = document.getElementById('status');
                if (!this.timecodeState.isRunning) {
                    statusEl.textContent = '⏹️ Stopped';
                    statusEl.className = 'status stopped';
                } else if (this.timecodeState.isPaused) {
                    statusEl.textContent = '⏸️ Paused';
                    statusEl.className = 'status paused';
                } else {
                    statusEl.textContent = '▶️ Running';
                    statusEl.className = 'status running';
                }
            }

            updateConnectionStatus(status) {
                const statusEl = document.getElementById('connectionStatus');
                statusEl.className = `connection-status ${status}`;
                
                switch (status) {
                    case 'connected':
                        statusEl.textContent = this.isLeader ? '🎯 Connected (Leader)' : '👥 Connected (Follower)';
                        break;
                    case 'connecting':
                        statusEl.textContent = '🔄 Connecting...';
                        break;
                    case 'disconnected':
                        statusEl.textContent = '📡 Ready to Connect';
                        break;
                }
            }

            updateParticipantCount() {
                const count = this.connections.size + 1; // +1 for self
                document.getElementById('participants').textContent = `👥 Participants: ${count}`;
            }

            updateUI() {
                const sessionSetup = document.getElementById('sessionSetup');
                const sessionInfo = document.getElementById('sessionInfo');
                const leaderControls = document.getElementById('leaderControls');
                const currentSessionId = document.getElementById('currentSessionId');
                const deviceIdToShare = document.getElementById('deviceIdToShare');

                if (this.sessionId) {
                    sessionSetup.classList.add('hidden');
                    sessionInfo.classList.remove('hidden');
                    currentSessionId.textContent = this.sessionId;
                    
                    if (this.isLeader && this.peer && this.peer.id) {
                        deviceIdToShare.textContent = this.peer.id;
                    }
                    
                    if (this.isLeader) {
                        leaderControls.classList.add('active');
                    } else {
                        leaderControls.classList.remove('active');
                        this.startUpdateLoop();
                    }
                    
                    this.updateParticipantCount();
                } else {
                    sessionSetup.classList.remove('hidden');
                    sessionInfo.classList.add('hidden');
                    leaderControls.classList.remove('active');
                }
            }

            startUpdateLoop() {
                this.stopUpdateLoop();
                this.updateInterval = setInterval(() => {
                    this.updateDisplay();
                }, 100);
            }

            stopUpdateLoop() {
                if (this.updateInterval) {
                    clearInterval(this.updateInterval);
                    this.updateInterval = null;
                }
            }
        }

        const timecodeManager = new PeerTimecodeManager();

        function createSession() {
            timecodeManager.createSession();
        }

        function joinSession() {
            timecodeManager.joinSession();
        }

        function leaveSession() {
            timecodeManager.leaveSession();
        }

        function startTimer() {
            timecodeManager.start();
        }

        function pauseTimer() {
            timecodeManager.pause();
        }

        function resetTimer() {
            timecodeManager.reset();
        }

        function adjustOffset(seconds) {
            timecodeManager.adjustOffset(seconds);
        }

        function setCustomOffset() {
            const offsetInput = document.getElementById('offsetInput');
            const value = parseInt(offsetInput.value) || 0;
            timecodeManager.setOffset(value);
            offsetInput.value = '';
        }

        function copySessionId() {
            const sessionId = document.getElementById('currentSessionId').textContent;
            navigator.clipboard.writeText(sessionId).then(() => {
                const btn = event.target;
                const originalText = btn.textContent;
                btn.textContent = '✅ Copied!';
                setTimeout(() => {
                    btn.textContent = originalText;
                }, 2000);
            }).catch(() => {
                // Fallback for older browsers
                const textArea = document.createElement('textarea');
                textArea.value = sessionId;
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);
                alert('Session ID copied to clipboard!');
            });
        }

        // Initialize
        timecodeManager.updateDisplay();
        timecodeManager.updateStatus();

        // Handle Enter key
        document.getElementById('sessionIdInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                joinSession();
            }
        });

        // Handle page visibility
        document.addEventListener('visibilitychange', function() {
            if (!document.hidden && !timecodeManager.isLeader) {
                timecodeManager.updateDisplay();
            }
        });
    </script>
</body>
</html>